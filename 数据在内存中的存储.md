1. 整数在内存中的存储
2. 大小端字节序和字节序判断
3. 浮点数在内存中的存储


# 1.整数在内存中的存储
* 整数在内存中存储的是二进制数字-补码
==原因:使用补码,可以将符号位和数值域统一处理
同时,加法和减法也可以统一处理(CPU只有加法器)此外,补码和原码相互转换,其运算过程是相同发,不需要额外的的硬件电路。==
* 二进制数字具有:原码,反码,补码三种表现形式
* 有符号的整数,三种表示方法均有符号位和数值位两部分,符号为都是用"0"表示正数,用"1"表示负数,最高位的一位被当做是符号位,剩余的都是数值位
* 整数的取值范围:`<>limits.h`中定义

## 1.1原码,反码,补码
1)正数的原码,反码,补码都相同。
   负数的原码,反码,补码三种表示方法各不相同
 2)原码: 直接将数值按照正负数形式翻译成二进制得到的就是原码
反码:将原码的符号位不变,其他位依次暗位取反就可以得到反码
补码:反码+1得到补码

# 2.大小端字节序和字节序的判断

## 2.1大小端字节序的概念
超过一个字节的数据在内存中存储的时候，就有存储顺序的问题，按照不同的存储顺序，我们分
为大端字节序存储和小端字节序存储
==大端(存储)模式:== 指数据的低位字节内容保存在内存的高地址处，而数据的高位字节内容，保存在内存的低地址处。
==小端(存储)模式:== 指数据的低位字节内容保存在内存的低地址处，而数据的高位字节内容，保存在内存的高地址处。
![[Pasted image 20240809083621.png]]

```
int check_sys(int number)
{
	if (*((char*)&number) == 1)//在内存中 大端字节序存储顺序 00 00 00 01 (按升序顺序存储)
		return 1;              //        小端字节序存储顺序 01 00 00 00 (按逆序顺序存储)
	//&number拿到整型的第一个字节的地址 判断第一个字节的地址是否是元素1 如果是则是小端字节序存储
	else
		return 0;
}
int main()
{
	int n = 1;
	int ret = check_sys(n);
	if (ret == 1)
		printf("小端字节序模式");//当前环境是小端字节序模式存储
	else
		printf("大端字节序模式");
	return 0;
}
```

```
int main()
{
	char a[1000];//下标为0~999
	int i = 0;
	for (i = 0; i < 1000; i++)
	{
		a[i] = -1 - i;
	}
	//-128-1 = 127
	//-1 -2 -3 -4 -5...-127 -128  127 126 .... 4 3 2 1 0 -1 -2
	printf("%zd", strlen(a));//strlen计算字符串长度,统计遇到\0(ascii码值为0)之前的字符个数
	//在0之前有255个元素
	return 0;
}
```
![[Pasted image 20240809102904.png]]

# 3.浮点数的存储
_常见的浮点数:3.14159,1E10(1.0*10^10-1.0乘10的10次方)等,浮点数家族包括==float,double,long,double类型==
浮点数表示的范围:`<float.h>`中定义_
根据国际标准IEEE(电气和电子工程协会) 754_任意一个二进制浮点数V可以表示成:==V=(-1)^s`*` M`*`2^E ==_
* (-1)^s表示符号位,当S=0,V为整数,当S=1,V为负数
* M表示有效数字,M是大于等于1小于2的  (1<=M<2)
* 2^E表示指数位*
* ==浮点数的春初其实存储的就是S,M,E相关的值==
**以5.5为例**
![[Pasted image 20240811092838.png]]
**IEEE 754规定
对于32位的浮点数(float),最高的1位存储符号位S,接着的8位存储E,剩下的23位存储有效数字M(不够23位补0)
对于64位的浮点数(double),最高的1位存储符号位S,接着的11位存储指数E,剩下的52位存储有效数字M**
![[Pasted image 20240811093502.png]]

## 3.1对有效数字M的规定
**1<=M<2，也就是说，M可以写成1.xxxxxx的形式，其中xxxxxx表示小数部分。
IEEE754规定，在计算机内部保存M时，默认这个数的第一位总是1，因此可以被舍去，只保存后面的xxxxxx表示小数部分。比如保存1.01的时候，只保存01，等到读取的时候，再把第一位的1加上去。这样做的目的是节省1位有效数字。以32位浮点数为例，留给M只有23位，将第一位的1舍去以后，等于可以保存24位有效数字**

## 3.2对指数E的规定
==E为一个无符号整数(unsigned int)==
**这意味着，如果E为8位，它的取值范围为0~255；如果E为11位，它的取值范围为0~2047。但是，我们知道，科学计数法中的E是可以出现负数的，所以IEEE754规定，存入内存时E的真实值必须再加上一个中间数，对于8位的E，这个中间数是127；对于11位的E，这个中间数是1023。比如，2^10的E是10，所以保存成32位浮点数时，必须保存成10+127=137，即10001001**

```
int main()
{
	float f = 5.5;
	//5.5 - 转换成二进制数字 101.1
	//转换成V = (-1)^0 *1.011*2^2
	//即 S = 0,M = 1.011 ,E = 2
	// 对于E的存储 要加上一个中间数 单精度浮点数为127 双精度浮点数为1023 E = 2+127 = 129
	//对于32位单精度浮点数 最高的1位存储符号位S,接着的8位存储E,剩下的23位存储有效数字M
	// 对于E的存储,只存储小数点后面的小数 011 不够23位补0
	// 010000000101100000000000000000000
	//转成16进制数字
	//40 B0 00 00-小端字节序存储方式
	return 0;
}
```

## 3.3浮点数取的过程
1) **E不全为0或者不全为1**
2) **E全为0**
_浮点数的指数E = 1-127 或者(1-1023)即为真实值,有效数字M不再加上第一位的1,而是还原为0.xxxxxx的小数,这样是为了表示士0,以及很接近0的很小的数字_
3) **E全为1**
_如果有效数字M全为0,表示士无穷大(正负取决于符号位S)_


 
